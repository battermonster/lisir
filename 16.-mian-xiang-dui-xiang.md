# 16.面向对象

## 面向对象编程介绍 <a id="&#x9762;&#x5411;&#x5BF9;&#x8C61;&#x7F16;&#x7A0B;&#x4ECB;&#x7ECD;"></a>

**请用程序描述如下事情：**

A同学报道登记信息

B同学报道登记信息

C同学报道登记信息

A同学做自我介绍

B同学做自我介绍

C同学做自我介绍

```python
stu_a= {
        "name":"A",
        "age":21,
        "gender":1,
        "hometown":"河北"
}
stu_b = {
        "name":"B",
        "age":22,
        "gender":0,
        "hometown":"山东"
}
stu_c = {
        "name":"C",
        "age":20,
        "gender":1,
        "hometown":"安徽"
}
def stu_intro(stu):
        """自我介绍"""
for key, value in stu.items():
        print("key=%s, value=%d"%(key,value))

stu_intro(stu_a)
stu_intro(stu_b)
stu_intro(stu_c)
```

考虑现实生活中，我们的思维方式是放在学生这个个人上，是学生做了自我介绍。而不是像我们刚刚写出的代码，先有了介绍的行为，再去看介绍了谁。

**用我们的现实思维方式该怎么用程序表达呢？**

```python
stu_a = Student(个人信息)
stu_b = Student(个人信息)
stu_c = Student(个人信息)
stu_a.intro()
stu_a.intro()
stu_a.intro()
```

面向过程：根据业务逻辑从上到下写代码

面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程

面向过程编程最易被初学者接受，其往往用一长段代码来实现指定功能，开发过程的思路是将数据与函数按照执行的逻辑顺序组织在一起，数据与函数分开考虑。

```python
def 发送邮件(内容)
        #发送邮件提醒
        连接邮箱服务器
        发送邮件
        关闭连接

while True：

        if cpu利用率 > 90%:
                发送邮件('CPU报警')

        if 硬盘使用空间 > 90%:
                发送邮件('硬盘报警')

        if 内存占用 > 80%:
                发送邮件('内存报警')
```

今天我们来学习一种新的编程方式：面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）

1）解决小白买汽车的事

第一种方式:

> 1\)在网上查资料口碑
>
> 2\)根据自己预算和喜好看上了一款野马轿车 中配 35万
>
> 3\)去市场找到卖车各种店无法判断是否是新车 随便找了一家
>
> 4\)找到业务员,业务员推荐了另外一款 配置更高价格便宜,也是福特公司出的售价28万
>
> 5\)砍价2小时 付款27.99万
>
> 6\)成交
>
> 回去之后发现各种问题

第二种方式 :

> 1\)找一个靠谱的买车高手
>
> 2\)给钱交易

面向对象和面向过程都是解决问题的一种思路而已

买车第一种方式:

1. 强调的是步骤、过程、每一步都是自己亲自去实现的
2. 这种解决问题的思路我们就叫做面向过程

第二种方式:

1. 强调的是买车高手, 买车高手是处理这件事的主角,对我们而言,我们并不必亲自实现整个步骤只需要调用买车高手就可以解决问题
2. 这种解决问题的思路就 是面向对象

* 用面向对象的思维解决问题的重点
  * 当遇到一个需求的时候不用自己去实现，如果自己一步步实现那就是面向过程
  * 应该找一个专门做这个事的人来做
  * 面向对象是基于面向过程的

解决购买机票的问题

第一种方式（面向过程）:

> 1去登陆民航官网
>
> 2登录账号
>
> 3添加乘机人
>
> 4选择目的地
>
> 5选择价位
>
> 6付款
>
> 7值机登机

第二种方式（面向对象）:

> 1交给助理订票
>
> 2值机登机



需要了解的定义性文字:

面向对象\(object-oriented ;简称: OO\) 至今还没有统一的概念 我这里把它定义为: 按人们 认识客观世界的系统思维方式,采用基于对象\(实体\) 的概念建立模型,模拟客观世界分析、设 计、实现软件的办法。

面向对象编程\(Object Oriented Programming-OOP\) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。



## 类和对象 <a id="&#x7C7B;&#x548C;&#x5BF9;&#x8C61;"></a>

面向对象编程的2个非常重要的概念：类和对象

对象是面向对象编程的核心，在使用对象的过程中，为了将具有共同特征和行为的一组对象抽象定义，提出了另外一个新的概念——类

类就相当于制造游艇时的图纸，用它来进行创建的游艇就相当于对象

##  类

```python
人以类聚 物以群分。
具有相似内部状态和运动规律的实体的集合(或统称为抽象)。 
具有相同属性和行为事物的统称
好比生物界的各种植物类动物类
```

类是抽象的,在使用的时候通常会找到这个类的一个具体的存在,使用这个具体的存在。一个类可以找到多个对象

![](.gitbook/assets/u5475p622dt20101209150827.jpg)

### 2. 对象 <a id="2-&#x5BF9;&#x8C61;"></a>

```python
某一个具体实物的存在 ,在现实世界中可以是看得见摸得着的。

实际生产出来的
```

![](.gitbook/assets/t0129149f6d6e0f94ef.jpg)

### 3. 类和对象之间的关系 <a id="3-&#x7C7B;&#x548C;&#x5BF9;&#x8C61;&#x4E4B;&#x95F4;&#x7684;&#x5173;&#x7CFB;"></a>

![](.gitbook/assets/1541756211-1.png)

犬类分很多品种。

小总结：类就是创建对象的模板

### 4. 练习：区分类和对象 <a id="4-&#x7EC3;&#x4E60;&#xFF1A;&#x533A;&#x5206;&#x7C7B;&#x548C;&#x5BF9;&#x8C61;"></a>

```python
汽车 类
轮船 类 
小王 对象
狗 类
大狗 类 
李四 对象 
水果 类
苹果 类 
```

### 5. 类的构成 <a id="5-&#x7C7B;&#x7684;&#x6784;&#x6210;"></a>

类\(Class\) 由3个部分构成

* 类的名称:类名
* 类的属性:数据特征
* 类的方法:允许对进行操作的方法 \(行为\)

 **举例：**

人类:

* 事物名称\(类名\):人
* 属性:身高、年龄、性别
* 方法（行为）:吃、喝、睡、说话、跑、跳、学习

犬类：

* 类名:狗
* 属性:品种 、毛色、性别、
* 方法\(行为\):叫 、跑、咬、吃

### 类的抽象 <a id="6-&#x7C7B;&#x7684;&#x62BD;&#x8C61;"></a>

如何把日常生活中的事物抽象成程序中的类?

拥有相同\(或者类似\)属性和行为的对象都可以抽像出一个类

方法:一般名词都是类\(名词提炼法\)

练一练：

找出这句话中的类

有个美女在街上遛狗没拴狗绳把路边的草地踩了还在草地上拉了粑粑，拉完以后还把人给咬了。



## 定义类 <a id="&#x5B9A;&#x4E49;&#x7C7B;"></a>

定义一个类，格式如下：

```python
class 类名:
    方法列表
```

demo：定义一个Car类

```python
# 定义类
class Car:
    # 方法
def getCarInfo(self):
    print('车轮子个数:%d, 颜色%s'%(self.wheelNum, self.color))

def move(self):
    print("车正在移动...")
```

**说明：**

* 定义类时有2种：新式类和经典类，上面的Car为经典类，如果是Car\(object\)则为新式类
* 类名 的命名规则按照"大驼峰"



## 创建对象 <a id="&#x521B;&#x5EFA;&#x5BF9;&#x8C61;"></a>

通过上一节课程，定义了一个Car类；就好比有车一个张图纸，那么接下来就应该把图纸交给生成工人们去生产了

Python中，可以根据已经定义的类去创建出一个个对象

创建对象的格式为:

```python
对象名 = 类名()
```

创建对象demo:

```python

# 定义类
class Car:
    # 移动
    def move(self):
        print('车在加速...')

    # 按喇叭
    def toot(self):
        print("车在鸣笛...叭叭叭..")


# 创建一个对象，并用变量BMW来保存它的引用
BMW = Car()
BMW.color = '黑色'
BMW.wheelNum = 4 #轮子数量
BMW.move()
BMW.toot()
print(BMW.color)
print(BMW.wheelNum)
```

### 总结： <a id="&#x603B;&#x7ED3;&#xFF1A;"></a>

* BMW = Car\(\)，这样就产生了一个Car的实例对象，此时也可以通过实例对象BMW来访问属性或者方法
* 第一次使用BMW.color = '黑色'表示给BMW这个对象添加属性，如果后面再次出现BMW.color = xxx表示对属性进行修改
* BMW是一个对象，它拥有属性（数据）和方法（函数）
* 当创建一个对象时，就是用一个模子，来制造一个实物 

![](.gitbook/assets/t01383b5800c9856a5e.jpg)



## `__init__()`方法 <a id="init&#x65B9;&#x6CD5;"></a>

想一想:

> 在上一小节的demo中，我们已经给BMW这个对象添加了2个属性，wheelNum（车的轮胎数量）以及color（车的颜色），试想如果再次创建一个对象的话，肯定也需要进行添加属性，显然这样做很费事，那么有没有办法能够在创建对象的时候，就顺便把车这个对象的属性给设置呢？

答:

> `__init__()`方法

### 使用方式 <a id="&#x4F7F;&#x7528;&#x65B9;&#x5F0F;"></a>

```python
def 类名:
    #初始化函数，用来完成一些默认的设定
    def __init__():
        pass
```

### `__init__()`方法的调用 <a id="init&#x65B9;&#x6CD5;&#x7684;&#x8C03;&#x7528;"></a>

```python
# 定义汽车类
class Car:

    def __init__(self):
        self.wheelNum = 4
        self.color = '骚红'

    def move(self):
        print('正在加速前进')

# 创建对象
BMW = Car()

print('车的颜色为:%s'%BMW.color)
print('车轮胎数量为:%d'%BMW.wheelNum)

#输出
>>>车的颜色为：红色
>>>车的轮胎数量为：4
```

**总结**

> 当创建Car对象后，在没有调用`__init__()`方法的前提下，BMW就默认拥有了2个属性wheelNum和color，原因是`__init__()`方法是在创建对象后，就立刻被默认调用了

### 想一想 <a id="&#x60F3;&#x4E00;&#x60F3;"></a>

> 既然在创建完对象后`__init__()`方法已经被默认的执行了，那么能否让对象在调用`__init__()`方法的时候传递一些参数呢？如果可以，那怎样传递呢？

```python

# 定义汽车类
class Car:

    def __init__(self, newWheelNum, newColor):
        self.wheelNum = newWheelNum
        self.color = newColor

    def move(self):
        print('正在加速前进')

# 创建对象
BMW = Car(4, 'red')

print('车的颜色为:%s'%BMW.color)
print('车轮子数量为:%d'%BMW.wheelNum)
#输出
>>>车的颜色为：red
>>>车轮子数量为：4
```

**总结**

1. `__init__()`方法，在创建一个对象时默认被调用，不需要手动调用
2. `__init__(self)`中，默认有1个参数名字为self，如果在创建对象时传递了2个实参，那么`__init__(self)`中出了self作为第一个形参外还需要2个形参，例如`__init__(self,x,y)`
3. `__init__(self)`中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递进去



## "magic"方法 <a id="&#x9B54;&#x6CD5;&#x65B9;&#x6CD5;"></a>

###  打印id\(\) <a id="1-&#x6253;&#x5370;id"></a>

如果把BMW使用print进行输出的话，即看到的是创建出来的BMW对象在内存中的地址。

###  定义`__str__()`方法 <a id="2-&#x5B9A;&#x4E49;str&#x65B9;&#x6CD5;"></a>

```python
class Car:

    def __init__(self, newWheelNum, newColor):
        self.wheelNum = newWheelNum
        self.color = newColor

    def __str__(self):
        msg = "你好。。。我的颜色是" + self.color + "我有" + int(self.wheelNum) + "个轮胎..."
        return msg

    def move(self):
        print('车正在加速')


BMW = Car(4, '炫丽红')
print(BMW)
```

![](../Images/Snip20161023_86.png)

**总结**

* 在python中方法名如果是`__xxxx__()`的，那么就有特殊的功能，因此叫做“魔法”方法
* 当使用print输出对象的时候，只要自己定义了`__str__(self)`方法，那么就会打印从在这个方法中return的数据

## self

### 理解self <a id="1-&#x7406;&#x89E3;self"></a>

self代表类的实例，而不是类。

```python
class test:
    def dpp(self):
        print(self)
        print(self.__class__)
a = test()
t.dpp()
执行结果：
<__main__.test object at 0x000000000284E080>
<class'__main__.test'>
```

注意：把self换成this，结果也一样，但Python中最好用约定俗成的self。

 从上面的例子中可以很明显的看出，self代表的是类的实例。而`self.__class__`则指向类。

#### 总结 <a id="&#x603B;&#x7ED3;"></a>

* 所谓的self，可以理解为自己
* 可以把self当做C++中类里面的this指针一样理解，就是对象自身的意思
* 某个对象调用其方法时，python解释器会把这个对象作为第一个参数传递给self，所以开发者只需要传递后面的参数即可

## **`__del__()`方法**

创建对象后，python解释器默认调用`__init__()`方法；

当删除一个对象时，python解释器也会默认调用一个方法，这个方法为`__del__()`方法

```python
import time
class Animal(object):

    # 初始化方法
    # 创建完对象后会自动被调用
    def __init__(self, name):
        print('__init__方法被调用')
        self.__name = name


    # 析构方法
    # 当对象被删除时，会自动被调用
    def __del__(self):
        print("__del__方法被调用")
        print("%s对象马上被干掉了..."%self.__name)

# 创建对象
dog = Animal("哈皮狗")

# 删除对象
del dog


cat = Animal("波斯猫")
cat2 = cat
cat3 = cat

print("---马上 删除cat对象")
del cat
print("---马上 删除cat2对象")
del cat2
print("---马上 删除cat3对象")
del cat3

print("程序2秒钟后结束")
time.sleep(2)
```



**总结**

* 当有1个变量保存了对象的引用时，此对象的引用计数就会加1
* 当使用del删除变量指向的对象时，如果对象的引用计数不会1，比如3，那么此时只会让这个引用计数减1，即变为2，当再次调用del时，变为1，如果再调用1次del，此时会真的把对象进行删除

